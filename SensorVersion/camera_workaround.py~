import subprocess
import time
import threading
import numpy as np
import os

_capturing = False  # prevents overlapping captures

def _clean_env():
    env = {
        k: v
        for k, v in os.environ.items()
        if k not in ("PYTHONPATH", "VIRTUAL_ENV", "PATH")
    }
    env["PATH"] = "/usr/bin:/bin"
    return env

def capture_frame():
    result = subprocess.run(
        ["python3", "camera.py"], capture_output=True, env=_clean_env()
    )
    if result.returncode != 0:
        print("Camera error:", result.stderr.decode())
        return None
    shape = np.frombuffer(result.stdout[:12], dtype=np.int32)
    frame = np.frombuffer(result.stdout[12:], dtype=np.uint8).reshape(shape)
    return frame

def _do_capture(output_path):
    global _capturing
    try:
        subprocess.run(
            ["python3", "camera.py", "--save", output_path],
            env=_clean_env()
        )
        print(f"[CAM] Saved {output_path}")
    except Exception as e:
        print(f"[CAM] Error: {e}")
    finally:
        _capturing = False

def capture_picture():
    output_path="image%Y-%m-%d_%H-%M-%S.jpg"
    global _capturing
    if _capturing:
        print("[CAM] Already capturing, skipping.")
        return
    _capturing = True
    thread = threading.Thread(target=_do_capture, args=(output_path,), daemon=True)
    thread.start()

if __name__ == "__main__":
    start_time = time.time()
    result = capture_frame()
    print(f"Frame capture took {time.time() - start_time:.2f}s")

    start_time = time.time()
    capture_picture()
    time.sleep(3)  # wait for background thread in test
    print(f"Picture capture took {time.time() - start_time:.2f}s")
